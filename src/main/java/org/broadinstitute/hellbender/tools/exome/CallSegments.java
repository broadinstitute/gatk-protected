package org.broadinstitute.hellbender.tools.exome;

import org.broadinstitute.hellbender.cmdline.Argument;
import org.broadinstitute.hellbender.cmdline.CommandLineProgram;
import org.broadinstitute.hellbender.cmdline.CommandLineProgramProperties;
import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;
import org.broadinstitute.hellbender.cmdline.programgroups.ExomeAnalysisProgramGroup;

import java.io.File;
import java.util.List;

/**
 * Calls segments as amplified, deleted, or copy number neutral given files containing tangent-normalized
 * read counts by target and a list of segments
 *
 * @author David Benjamin
 */
@CommandLineProgramProperties(
        summary = "Call segments as amplified, deleted, or copy number neutral given files containing tangent-normalized" +
                " read counts by target and a list of segments",
        oneLineSummary = "Call segments as amplified, deleted, or copy number neutral",
        programGroup = ExomeAnalysisProgramGroup.class
)
public final class CallSegments extends CommandLineProgram{

    protected static final String SEGFILE_SHORT_NAME = "S";
    protected static final String SEGFILE_LONG_NAME = "segments";

    protected static final String TARGET_FILE_SHORT_NAME = "T";
    protected static final String TARGET_FILE_LONG_NAME = "targets";

    protected static final String OUTPUT_SHORT_NAME = StandardArgumentDefinitions.OUTPUT_SHORT_NAME;
    protected static final String OUTPUT_LONG_NAME = StandardArgumentDefinitions.OUTPUT_LONG_NAME;

    protected static final String Z_THRESHOLD_SHORT_NAME = "Z";
    protected static final String Z_THRESHOLD_LONG_NAME = "threshold";

    protected static final String LEGACY_SEG_FILE_SHORT_NAME = "l";
    protected static final String LEGACY_SEG_FILE_LONG_NAME = "legacy";

    protected static final String EXPERIMENTAL_CALLER_SHORT_NAME = "e";
    protected static final String EXPERIMENTAL_CALLER_LONG_NAME = "experimental";

    protected static final String SAMPLE_LONG_NAME = "sample";

    @Argument(
            doc = "normalized read counts input file.",
            shortName = TARGET_FILE_SHORT_NAME,
            fullName = TARGET_FILE_LONG_NAME,
            optional = false
    )
    protected File targetsFile;

    @Argument(
            doc = "segments files",
            shortName = SEGFILE_SHORT_NAME,
            fullName = SEGFILE_LONG_NAME,
            optional = false
    )
    protected File segmentsFile;

    @Argument(
            doc = "Called segments output",
            shortName = OUTPUT_SHORT_NAME,
            fullName = OUTPUT_LONG_NAME,
            optional = false
    )
    protected File outFile;

    @Argument(
            doc = "Sample",
            fullName = SAMPLE_LONG_NAME,
            optional = false
    )
    protected String sample;

    @Argument(
            doc = "(Advanced) Number of standard deviations of targets' coverage a segment mean must deviate from copy neutral"
            + " to be considered an amplification or deletion.  This parameter controls the trade-off between"
            + " sensitivity and specificity, with smaller values favoring sensitivity.\n"
            + " NOTE: This option is ignored unless using the experimental caller (-" + EXPERIMENTAL_CALLER_SHORT_NAME + ").",
            shortName = Z_THRESHOLD_SHORT_NAME,
            fullName = Z_THRESHOLD_LONG_NAME,
            optional = true
    )
    protected double zThreshold = CnvCaller.DEFAULT_Z_SCORE_THRESHOLD;

    @Argument(
            doc = "(Advanced) Assume that the input seg file is using the legacy format (e.g. generated by python ReCapSeg)."
            + "  NOTE:  The output will be in the format used by this program -- i.e. no preservation of legacy field names, etc.",
            shortName = LEGACY_SEG_FILE_SHORT_NAME,
            fullName = LEGACY_SEG_FILE_LONG_NAME,
            optional = true
    )
    protected boolean isLegacyFormatSegFile = false;

    @Argument(
            doc = "(Advanced and Experimental) Use the new hellbender caller.  This will take in the new segment file format."
            + "  No need to call with legacy format.",
            shortName = EXPERIMENTAL_CALLER_SHORT_NAME,
            fullName = EXPERIMENTAL_CALLER_LONG_NAME,
            optional = true
    )
    protected boolean useExperimentalCaller = false;

    @Override
    protected Object doWork() {


        final TargetCollection<TargetCoverage> targets = TargetCoverageUtils.readModeledTargetFileIntoTargetCollection(targetsFile);

        List<ModeledSegment> segments = null;
        if (isLegacyFormatSegFile) {
            segments = SegmentUtils.readModeledSegmentsFromLegacySegfile(segmentsFile);
        } else {
            segments = SegmentUtils.readModeledSegmentsFromSegfile(segmentsFile);
        }

        //add calls to segments in-place
        if (useExperimentalCaller) {
            CnvCaller.makeCalls(targets, segments, zThreshold);
        } else {
            ReCapSegCaller.makeCalls(targets, segments);
        }

        SegmentUtils.writeModeledSegmentsToSegfile(outFile, segments, sample);

        return "SUCCESS";
    }
}
